"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[3739],{9318(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"humanoid-kinematics-dynamics","title":"An Introduction to Humanoid Robot Kinematics and Dynamics","description":"Building a humanoid robot that can move gracefully and perform useful tasks requires a deep understanding of its kinematics and dynamics. These two fields of classical mechanics provide the mathematical foundation for modeling and controlling the robot\'s motion.","source":"@site/docs/18-humanoid-kinematics-dynamics.md","sourceDirName":".","slug":"/humanoid-kinematics-dynamics","permalink":"/docs/humanoid-kinematics-dynamics","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":18,"frontMatter":{"sidebar_position":18},"sidebar":"tutorialSidebar","previous":{"title":"Bridging the Gap: Sim-to-Real Transfer Techniques","permalink":"/docs/isaac-sim-to-real"},"next":{"title":"The Challenge of Bipedal Locomotion and Balance Control","permalink":"/docs/bipedal-locomotion"}}');var o=i(2540),t=i(3023);const r={sidebar_position:18},a="An Introduction to Humanoid Robot Kinematics and Dynamics",c={},l=[{value:"Kinematics: The Geometry of Motion",id:"kinematics-the-geometry-of-motion",level:2},{value:"Forward Kinematics (FK)",id:"forward-kinematics-fk",level:3},{value:"Inverse Kinematics (IK)",id:"inverse-kinematics-ik",level:3},{value:"Dynamics: The Physics of Motion",id:"dynamics-the-physics-of-motion",level:2},{value:"Forward Dynamics",id:"forward-dynamics",level:3},{value:"Inverse Dynamics",id:"inverse-dynamics",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"an-introduction-to-humanoid-robot-kinematics-and-dynamics",children:"An Introduction to Humanoid Robot Kinematics and Dynamics"})}),"\n",(0,o.jsxs)(n.p,{children:["Building a humanoid robot that can move gracefully and perform useful tasks requires a deep understanding of its ",(0,o.jsx)(n.strong,{children:"kinematics"})," and ",(0,o.jsx)(n.strong,{children:"dynamics"}),". These two fields of classical mechanics provide the mathematical foundation for modeling and controlling the robot's motion."]}),"\n",(0,o.jsx)(n.h2,{id:"kinematics-the-geometry-of-motion",children:"Kinematics: The Geometry of Motion"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Kinematics"})," is concerned with the ",(0,o.jsx)(n.em,{children:"geometry"}),' of motion, without considering the forces that cause it. It answers the question: "If I set the robot\'s joint angles to specific values, where will its hand be?"']}),"\n",(0,o.jsx)(n.h3,{id:"forward-kinematics-fk",children:"Forward Kinematics (FK)"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Forward Kinematics"})," is the process of calculating the position and orientation of the robot's end-effectors (like its hands or feet) given the angles of all its joints. This is a relatively straightforward calculation. Starting from the base of the robot, you can use a series of transformations (multiplication of transformation matrices, one for each joint) to find the pose of any link in the robot's kinematic chain."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use Case"}),": Visualizing the robot's current pose in RViz or a simulator. Given the joint angles read from the motors, FK is used to draw the robot on the screen."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"inverse-kinematics-ik",children:"Inverse Kinematics (IK)"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Inverse Kinematics"})," is the reverse and much harder problem: given a desired position and orientation for the robot's end-effector (e.g., \"I want the robot's hand to be here\"), what are the joint angles required to achieve that pose?"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Challenges"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Multiple Solutions"}),": There are often many, sometimes infinite, possible joint configurations that result in the same end-effector pose. Think of how many ways you can touch your nose."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"No Solution"}),": The target pose might be unreachable."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Singularities"}),": There are certain configurations (like a fully extended arm) where the robot loses a degree of freedom, making it impossible to move in certain directions."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Solving IK"}),": IK is typically solved using iterative numerical optimization algorithms. In ROS 2, popular libraries like ",(0,o.jsx)(n.strong,{children:"MoveIt"})," provide powerful IK solvers."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use Case"}),": This is fundamental for any goal-oriented task. To pick up an object, the robot is given the target pose of the object, and an IK solver calculates the necessary joint angles to move the hand there."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"dynamics-the-physics-of-motion",children:"Dynamics: The Physics of Motion"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Dynamics"}),' is concerned with the relationship between motion and the forces and torques that cause it. It answers the question: "What torques do I need to apply at each joint to make the robot\'s hand follow a specific trajectory?"']}),"\n",(0,o.jsx)(n.h3,{id:"forward-dynamics",children:"Forward Dynamics"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Forward Dynamics"})," calculates the resulting acceleration of the robot's joints given a set of applied joint torques."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use Case"}),": This is primarily used in physics-based simulators like Gazebo. The simulator's physics engine uses forward dynamics to calculate how the robot will move in response to the motor commands."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"inverse-dynamics",children:"Inverse Dynamics"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Inverse Dynamics"})," is the process of calculating the torques required to achieve a desired set of joint accelerations (and thus, a desired motion)."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"The Equations of Motion"}),": The relationship between joint torques, joint positions, velocities, and accelerations is described by the robot's ",(0,o.jsx)(n.strong,{children:"equations of motion"}),":"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"\u03c4 = M(q) * q\u0308 + C(q, q\u0307) + G(q)"})}),"\n",(0,o.jsx)(n.p,{children:"Where:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"\u03c4"})," (tau) is the vector of joint torques."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"q"}),", ",(0,o.jsx)(n.code,{children:"q\u0307"}),", ",(0,o.jsx)(n.code,{children:"q\u0308"})," are the joint positions, velocities, and accelerations."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"M(q)"})," is the ",(0,o.jsx)(n.strong,{children:"mass matrix"}),", which represents the robot's inertia."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"C(q, q\u0307)"})," represents the ",(0,o.jsx)(n.strong,{children:"Coriolis and centrifugal forces"})," (which are significant during fast movements)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"G(q)"})," is the vector of ",(0,o.jsx)(n.strong,{children:"gravity torques"})," (the torques required to hold the robot's own weight)."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use Case"}),': Inverse dynamics is the foundation of many advanced control techniques. If you want a robot to follow a precise trajectory, you can use inverse dynamics to calculate the exact "feedforward" torques needed at every moment in time. This allows the robot to move much more accurately than with simple feedback controllers alone.']}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Understanding the interplay between kinematics and dynamics is crucial for humanoid robotics. Kinematics allows us to plan the robot's movements in space, while dynamics allows us to calculate the forces needed to bring those movements to life."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},3023(e,n,i){i.d(n,{R:()=>r,x:()=>a});var s=i(3696);const o={},t=s.createContext(o);function r(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);