"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[4292],{2107(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"urdf-sdf","title":"URDF and SDF: Describing Your Robot","description":"To simulate a robot in Gazebo or visualize it in RViz, you first need a way to describe its physical structure. ROS 2 and Gazebo use two primary formats for this: the Unified Robot Description Format (URDF) and the Simulation Description Format (SDF).","source":"@site/docs/11-urdf-sdf.md","sourceDirName":".","slug":"/urdf-sdf","permalink":"/my-book/docs/urdf-sdf","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Setting Up the Gazebo Simulation Environment","permalink":"/my-book/docs/gazebo-setup"},"next":{"title":"Physics and Sensor Simulation in Gazebo","permalink":"/my-book/docs/gazebo-physics-sensors"}}');var o=i(2540),r=i(3023);const t={sidebar_position:11},l="URDF and SDF: Describing Your Robot",a={},d=[{value:"URDF: The Standard for ROS",id:"urdf-the-standard-for-ros",level:2},{value:"URDF Limitations",id:"urdf-limitations",level:3},{value:"SDF: The Language of Gazebo",id:"sdf-the-language-of-gazebo",level:2},{value:"URDF vs. SDF: Which One to Use?",id:"urdf-vs-sdf-which-one-to-use",level:2}];function c(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"urdf-and-sdf-describing-your-robot",children:"URDF and SDF: Describing Your Robot"})}),"\n",(0,o.jsxs)(n.p,{children:["To simulate a robot in Gazebo or visualize it in RViz, you first need a way to describe its physical structure. ROS 2 and Gazebo use two primary formats for this: the ",(0,o.jsx)(n.strong,{children:"Unified Robot Description Format (URDF)"})," and the ",(0,o.jsx)(n.strong,{children:"Simulation Description Format (SDF)"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"urdf-the-standard-for-ros",children:"URDF: The Standard for ROS"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"URDF"})," is an XML-based format used in ROS to describe the kinematics and dynamics of a robot model. It is the standard for describing robots outside of simulation."]}),"\n",(0,o.jsxs)(n.p,{children:["A URDF file defines the robot as a tree of ",(0,o.jsx)(n.strong,{children:"links"})," and ",(0,o.jsx)(n.strong,{children:"joints"}),"."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<link>"})}),": A link represents a rigid body part of the robot (e.g., a forearm, a wheel, a torso). Each link has physical properties like mass and inertia, as well as visual and collision properties."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<visual>"})}),": Defines the appearance of the link (what it looks like). This is often a 3D mesh file (like ",(0,o.jsx)(n.code,{children:".dae"})," or ",(0,o.jsx)(n.code,{children:".stl"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<collision>"})}),": Defines the collision geometry of the link (its physical shape for collision checking). This can be a simple shape (like a box or cylinder) or a mesh."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<inertial>"})}),": Defines the dynamic properties of the link, including its mass and inertia matrix."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<joint>"})}),": A joint connects two links together and defines their relative motion."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.code,{children:"parent"})," and ",(0,o.jsx)(n.code,{children:"child"})]}),": Specifies which two links are being connected."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"type"})}),": The type of motion allowed by the joint. Common types include:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"revolute"}),": A hinge joint that rotates around a single axis (like an elbow)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"continuous"}),": A revolute joint with no angle limits (like a wheel)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"prismatic"}),": A sliding joint that moves along a single axis."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"fixed"}),": A rigid connection between two links."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example URDF Snippet:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<robot name="simple_arm">\r\n  \x3c!-- Base Link --\x3e\r\n  <link name="base_link">\r\n    ...\r\n  </link>\r\n\r\n  \x3c!-- Arm Link --\x3e\r\n  <link name="arm_link">\r\n    ...\r\n  </link>\r\n\r\n  \x3c!-- Joint connecting base to arm --\x3e\r\n  <joint name="base_to_arm_joint" type="revolute">\r\n    <parent link="base_link"/>\r\n    <child link="arm_link"/>\r\n    <origin xyz="0 0 0.5"/>\r\n    <axis xyz="0 1 0"/>\r\n    <limit effort="1000.0" lower="-1.57" upper="1.57" velocity="0.5"/>\r\n  </joint>\r\n</robot>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"urdf-limitations",children:"URDF Limitations"}),"\n",(0,o.jsx)(n.p,{children:"URDF is excellent for describing the kinematics of a single robot, but it has limitations:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"It cannot represent a closed-loop chain (a kinematic loop)."}),"\n",(0,o.jsx)(n.li,{children:"It cannot be used to describe non-robot items in the world (like lights, tables, or buildings)."}),"\n",(0,o.jsx)(n.li,{children:"It has limited support for specifying sensor models directly."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"sdf-the-language-of-gazebo",children:"SDF: The Language of Gazebo"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"SDF"})," is the native format for Gazebo. It is also an XML-based format, but it is a superset of URDF. SDF is designed to describe everything about a simulation, not just a single robot."]}),"\n",(0,o.jsx)(n.p,{children:"Key features of SDF:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"World Description"}),": Can describe an entire world, including robots, static objects, lights, physics properties, and more."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Support for Closed Loops"}),": Can model complex mechanisms that URDF cannot."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Detailed Sensor Models"}),": Provides a rich set of tags for defining sensors (cameras, LiDAR, IMUs) and their noise models."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Plugin Specification"}),": Allows you to specify which plugins should be loaded for a given model or sensor."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["You can think of SDF as a more complete language for simulation. While URDF describes ",(0,o.jsx)(n.em,{children:"what your robot is"}),", SDF describes ",(0,o.jsx)(n.em,{children:"what your simulation is"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"urdf-vs-sdf-which-one-to-use",children:"URDF vs. SDF: Which One to Use?"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use URDF as your primary robot description format"}),". It is the standard across the ROS ecosystem, and tools like RViz and MoveIt rely on it."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:["Use SDF for your Gazebo world files (",(0,o.jsx)(n.code,{children:".world"}),")"]}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["When you need to add Gazebo-specific features to your robot model (like sensors or plugins), you can add special ",(0,o.jsx)(n.code,{children:"<gazebo>"})," tags inside your URDF file. ROS tools will ignore these tags, but Gazebo will parse them."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example: Adding a Gazebo color tag to a URDF link"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<link name="my_link">\r\n  ...\r\n  <gazebo reference="my_link">\r\n    <material>Gazebo/Red</material>\r\n  </gazebo>\r\n</link>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["For complex simulations, you might convert your URDF to an SDF file on the fly when you spawn the robot into Gazebo. The ",(0,o.jsx)(n.code,{children:"gazebo_ros"})," package provides tools to do this automatically. This approach allows you to maintain a single, canonical URDF for your robot while still leveraging the full power of SDF for simulation."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},3023(e,n,i){i.d(n,{R:()=>t,x:()=>l});var s=i(3696);const o={},r=s.createContext(o);function t(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);